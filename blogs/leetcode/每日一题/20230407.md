---
title: 移动石子直到连续 II
date: 2023-04-07
tags:
 - 力扣
 - 每日一题
 - 双指针
 - 滑动窗口
categories: 
 - 力扣
---

题目链接：[https://leetcode.cn/problems/moving-stones-until-consecutive-ii/](https://leetcode.cn/problems/moving-stones-until-consecutive-ii/)

难度：<font color="#FFA119">中等</font>

在一个长度 无限 的数轴上，第 i 颗石子的位置为 stones[i]。如果一颗石子的位置最小/最大，那么该石子被称作 端点石子 。

每个回合，你可以将一颗端点石子拿起并移动到一个未占用的位置，使得该石子不再是一颗端点石子。

值得注意的是，如果石子像 stones = [1,2,5] 这样，你将 无法 移动位于位置 5 的端点石子，因为无论将它移动到任何位置（例如 0 或 3），该石子都仍然会是端点石子。

当你无法进行任何移动时，即，这些石子的位置连续时，游戏结束。

要使游戏结束，你可以执行的最小和最大移动次数分别是多少？ 以长度为 2 的数组形式返回答案：answer = [minimum_moves, maximum_moves] 。

示例 1：
输入：[7,4,9]
输出：[1,2]
解释：
我们可以移动一次，4 -> 8，游戏结束。
或者，我们可以移动两次 9 -> 5，4 -> 6，游戏结束。

示例 2：
输入：[6,5,4,3,10]
输出：[2,3]
解释：
我们可以移动 3 -> 8，接着是 10 -> 7，游戏结束。
或者，我们可以移动 3 -> 7, 4 -> 8, 5 -> 9，游戏结束。
注意，我们无法进行 10 -> 2 这样的移动来结束游戏，因为这是不合要求的移动。

示例 3：
输入：[100,101,104,102,103]
输出：[0,0]

提示：
3 <= stones.length <= 10^4
1 <= stones[i] <= 10^9
stones[i] 的值各不相同。

虽然此题是中等题，但比较考验思维，长期作为所有中等题的top1。思考了很久也没什么好的想法，最后还是试图理解官解吧。

为了更好的理解，我们不妨先将 stones 从小到大排序，那么就有 stones[0] < stones[1] < stones[i] < stones[n-2] < stones[n-1]。

当 stones 是连续的时候，说明已经没有未占用的位置了，游戏将会结束。

首先先求最大值，这个比较好理解。我们第一步只能移动 stones[0] 或者 stones[n-1]，并且将其移动到最近的空位上，使其不是端点石子（其实移动到哪个空位都一样，主要是第一步是移动左端点的石子还是右端点的）。如果是前者，那么 stones[0] 到 stones[1] 中间的空位将被抛弃，可以保证的是 stones[1] 和 stones[2] 是连续的，那么剩下的工作就是通过移动最左端的石子补全空位，最后使得整个数组是连续的。后者也是同样的道理，第一步移动了 stones[n-1]，则 stones[n-1] 到 stones[n-2] 的空位被抛弃，然后继续移动补全空位使得连续就行。

那么我们就需要计算第一次移动之后剩下了多少个空位，就是我们需要移动的次数，而最大值就是这两种情况中较大的一个。

我举个例子可以让你更好理解，例如 stones = [0, 4, 5, 6, 9]，那么如果第一步移动 stones[0]，则数组的变化是这样的：[0, 4, 5, 6, 9] -> [4, 5, 6, 7, 9] -> [5, 6, 7, 8, 9]，一共移动了2次；如果第一步移动 stones[n-1]，则数组的变化是这样的：[0, 4, 5, 6, 9] -> [0, 3, 4, 5, 6] -> [0, 2, 3, 4, 5] -> [0, 1, 2, 3, 4]，一共移动了3次。

通过分析我们可以得到，如果第一步移动 stones[0]，则移动次数为 stones[n-1] - stones[1] + 1 - (n - 1)；如果第一步移动 stones[n-1]，则移动次数为 stones[n-2] - stones[0] + 1 - (n - 1)。

其实就是计算 第一次移动后还有多少个位置，然后减掉石子的个数，而因为已经移动了一次了，还需要再减1，得到的就是空位的个数，也就是需要移动的次数。

最小值可以利用滑动窗口来做。官方的解释看着头晕，自己尝试理解了一下，就是最后的结果肯定是一个长度为 n 的连续数组，那么当我们长度为 n 的滑动窗口中石子的数量（设为k）最多的时候，两端剩下 n - k 个石子，把他们不到滑动窗口中的空位中就可以了，移动的次数即为 n - k，也就是最小值。

```js
var numMovesStonesII = function(stones) {
    let n = stones.length;
    stones.sort((a, b) => a - b);
    // 如果本身就是连续的，总位置数刚好等于石子的数量
    if (stones[n - 1] - stones[0] + 1 == n) {
        return [0, 0];
    }
    let ma = Math.max(stones[n - 2] - stones[0] + 1, stones[n-1] - stones[1] + 1) - (n - 1);
    let mi = n;
    let j = 0;
    for (let i = 0; i < n; i++) {
        // 求出长度为 n 的滑动窗口中最右一块石头的位置
        while (j + 1 < n && stones[j + 1] - stones[i] + 1 <= n) {
            j++;
        }
        // 如果其中有连续的 n-1 个数，另外一个数 和 他们之间相隔距离超过 1 的情况， 这种情况滑动窗口一定在最左边或者最右边，且长度只有 n - 1。例如 1 2 3 4 8，那么我们只需要把 1 移动到 6，再把 8 移动到 5 就可以了，两步完成。
        // j - i + 1 为 窗口内石头的个数，stones[j] - stones[i] + 1 为窗口的长度
        if (j - i + 1 == n - 1 && stones[j] - stones[i] + 1 == n - 1) {
            mi = Math.min(mi, 2);
        } else {
            mi = Math.min(mi, n - (j - i + 1));
        }
        // 1 2 4 5 7
    }
    return [mi, ma];
};
```
真是妙啊，学习了~